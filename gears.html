
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Introduction to Gears &#8212; PyGears - HW Design: A Functional Approach</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/default.js"></script>
    <script src="_static/wavedrom.js"></script>
    <link rel="canonical" href="https://docs.pygears.org/gears.html" />
    <link rel="shortcut icon" href="_static/pygears.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Typing" href="typing.html" />
    <link rel="prev" title="Quick introduction" href="introduction.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="introduction-to-gears">
<span id="gears-introduction-to-gears"></span><h1>Introduction to Gears<a class="headerlink" href="#introduction-to-gears" title="Permalink to this headline">¶</a></h1>
<p><strong>PyGears</strong> is an ambitious attempt to create a Python framework that facilitates describing digital hardware. It aims to augment current RTL methodology to drastically increase <strong>composability</strong> of hardware modules. Ease of composition leads to better <strong>reusability</strong>, since modules that compose better can be used in a wider variety of contexts. Set of reusable components can then form a well-tested and documented library that significantly speeds up the development process.</p>
<p>For a guide through <strong>PyGears</strong> methodology, checkout <a class="reference external" href="https://docs.pygears.org/blog/riscv/introduction.html">blog series on implementing RISC-V in PyGears</a>.</p>
<p>For an introductory <strong>PyGears</strong> example, checkout <a class="reference internal" href="echo.html#echo-examples"><span class="std std-ref">echo</span></a>. A snippet is given below:</p>
<p><strong>PyGears</strong> proposes a single generic interface for all modules (<a class="reference internal" href="#gears-interface"><span class="std std-ref">read about the hardware implementation of the interface here</span></a>) and provides a way to use powerful features of Python language to compose modules written in an existing HDL (currently only supports SystemVerilog). Based on the Python description, <strong>PyGears</strong> generates functionally equivalent, synthesizable RTL code.</p>
<p>Furthermore, <strong>PyGears</strong> offers a way to write verification environment in high-level Python language and co-simulate the generated RTL with an external HDL simulator. <strong>PyGears</strong> features a completely free solution using <a class="reference external" href="http://www.veripool.org/wiki/verilator">Verilator</a> simulator and standard SystemVerilog simulators via the <a class="reference external" href="https://en.wikipedia.org/wiki/SystemVerilog_DPI">DPI</a> (tested on proprietary Questa and NCSim simulators).</p>
<p><strong>PyGears</strong> also features a <a class="reference external" href="https://github.com/bogdanvuk/pygears/tree/master/pygears/lib">library of standard modules</a> and the <a class="reference external" href="https://github.com/bogdanvuk/pygears/tree/master/pygears/lib">lib library</a> that are ready to be used in a <strong>PyGears</strong> design.</p>
<p>In <strong>PyGears</strong>, each HDL module is considered a Python function, called the <em>gear</em>, hence the design is described in form of a functional (gear) composition. In order for HDL modules to be composable in this way, they need to be designed in accordance with the <strong>Gears</strong> methodology. You should probably <a class="reference internal" href="#gears-introduction-to-gears"><span class="std std-ref">read a short intro to Gears</span></a> in order to understand this project from the hardware perspective.</p>
<p><strong>PyGears</strong> supports also the hierarchical gears which do not have a HDL implementation, but are defined in terms of other gears. Each gear accepts and returns interface objects as arguments, which represents module connections. This allows for a module composition to be described in terms of powerful functional concepts, such as: partial application, higher-order functions, function polymorphism.</p>
<p><strong>PyGears</strong> features a powerful system of <a class="reference internal" href="typing.html#typing"><span class="std std-ref">generic types</span></a>, which allows for generic modules to be described, as well as to perform type checking of the gear composition.</p>
<p>The main goal of the <strong>Gears</strong> hardware design methodology is to enable easy composition of hardware modules. <strong>Gears</strong> provides guidelines on how modules need to be implemented and standardizes the <a class="reference internal" href="#gears-interface"><span class="std std-ref">interface</span></a> between them. This methodology was inspired by the <a class="reference external" href="https://en.wikipedia.org/wiki/Category_theory">Category theory</a> and functional programming.</p>
<p>Modules that adhere to the <strong>Gears</strong> methodology are called <strong>gears</strong>. Gears are self-synchronizing, meaning that they can be composed without the need of some global control FSM. On the other hand, they add no overhead in terms of latency and induce little to no overhead in terms of the logic gates used.</p>
<p>Since the composition becomes easy when adhering to <strong>Gears</strong>, the design can be broken down/factored to small modules that implement basic functionalities, which is aligned with the <a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single responsibility principle</a>. Small modules with a single functionality are easier to understand, test, debug, maintain and most importantly: <strong>reuse</strong>. When using <strong>Gears</strong> for your project, you are basically building a library of well tested, well understood modules, that you can easily reuse.</p>
<section id="one-interface">
<span id="gears-interface"></span><h2>One interface<a class="headerlink" href="#one-interface" title="Permalink to this headline">¶</a></h2>
<p>The main idea behind standardized interfaces is to provide easy composition of the modules. These interfaces: AXI, Avalon, etc., have been used so far to compose large modules written in RTL called IPs, and they are popular for developing SoCs (System on chip). <strong>Gears</strong> tries to push this standardization all the way down to the basic building blocks like: counters, MUXs and FIFOs.</p>
<div class="figure" id="tikz-1" style="text-align: center"><p><img  src="_images/tikz-fb469c944d72dd32a859ee29fb8934cda7c66991.png" alt="Figure made with TikZ" /></p>
<p><span class="caption-text">DTI - Data Transfer Interface</span></p>
</div><p><strong>Gears</strong> proposes the use of a single interface type for gear communication, called DTI (Data Transfer Interface), throughout the design. Interface connects two gears, one which sends the data and the other one which receives it, called Producer and Consumer respectively. This interface DTI is a simple synchronous, flow-controlled interface, somewhat similar to AXI4-Stream, consisting of the following three signals:</p>
<ul class="simple">
<li><p><strong>Data</strong> - Variable width signal, driven by the Producer, which carries the actual data.</p></li>
<li><p><strong>Valid</strong> - Single bit wide signal, driven by the Producer, which signals when valid data is available on Data signal.</p></li>
<li><p><strong>Ready</strong> - Single bit wide signal, driven by the Consumer, which signals when the data provided by the Producer has been consumed.</p></li>
</ul>

<div style="overflow-x:auto">
<script type="WaveDrom">
{
  signal: [
  {name: 'clk', wave:   'p.........'},
  {},
  ['DTI',
  {name: 'data', wave:  'x=..x.==x.'},
  {},
  {name: 'valid', wave: '01..0.1.0.'},
  {name: 'ready', wave: '0..1....0.'}
  ],
  {},
  {name: 'event', wave: 'x..=x.==xx', data: ['ACK', 'ACK', 'ACK']}
],
head:{
  tock:0,
},
}
</script>
</div>
<p>Gears need to adhere to the following rules:</p>
<ol class="arabic simple">
<li><p>Producer shall initiate the data transfer by posting the data on Data signal, and rising Valid signal to high, as seen in cycle 1, 6 and 7 in the figure.</p></li>
<li><p>Consumer can start using the input data in the same cycle the Valid line went high.</p></li>
<li><p>Consumer can use the input data sent by the Producer for internal calculations for as many cycles as needed. For an example in cycles 1-3 in the figure.</p></li>
<li><p>When Consumer realizes that it is the last cycle in which it needs the input data, it raises the Ready signal to high. On the edge of the clock if both Valid and Ready signals are high, it is said that the Consumer acknowledged/consumed the data, or that the handshake has happened (cycles 3, 6 and 7 in the figure, marked also as ACK). This signals the Producer that in the following cycle new data transfer can be initiated, or Valid signal can be set to low (cycles 4, 5, 8 or 9 in the figure), which will pause the data transfer.</p></li>
<li><p>After initiating the transfer, Producer shall keep the Data signal unchanged and the Valid signal high until the handshake occurs, as seen in cycles 1-2 in the figure.</p></li>
<li><p>Producer can keep Valid signal low for as many cycles as needed, which will block the Consumer if it is waiting for new input data, as seen in cycles 4-5 in the figure.</p></li>
<li><p>There must be no combinatorial path from Ready to Valid signal on the Producer side. In other words, the Producer should not decide whether to output the data based on the state of the Consumer, but only based on its own inputs and internal state.</p></li>
<li><p>Consumer may decide whether to acknowledge the data based on the state of the Valid signal, i.e. there may exist a combinatorial path from Valid to Ready signal on the Consumer side.</p></li>
</ol>
</section>
<section id="powerful-type-system">
<span id="gears-type-system"></span><h2>Powerful type system<a class="headerlink" href="#powerful-type-system" title="Permalink to this headline">¶</a></h2>
<p>To enhance the composability, gear inputs and outputs are all assigned a type, which are usually generic, i.e. parameterized. Example of basic types are: Uint[T] and Int[T], which denote variable sized unsigned and signed integers. For an example Uint[16] is 16-bit wide unsigned integer. <strong>Gears</strong> defines complex types also, such as:</p>
<section id="tuple">
<h3>Tuple<a class="headerlink" href="#tuple" title="Permalink to this headline">¶</a></h3>
<p>Tuple combines multiple data types, even other Tuples. They are akin to structs or records. For an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example_t</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">]]]</span>  <span class="c1"># (u8, (u16, u16))</span>
</pre></div>
</div>
<p>is a structure with two fields, one 8-bit unsigned integer and another again tuple with two 16-bit unsigned integer fields. In SystemVerilog this example type would be encoded as:</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="k">packed</span>
<span class="p">{</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">15</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">field1</span><span class="p">;</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">15</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">field0</span><span class="p">;</span>
<span class="p">}</span> <span class="n">example_sub_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="k">packed</span>
<span class="p">{</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">7</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">field0</span><span class="p">;</span>
   <span class="n">example_sub_t</span> <span class="n">field1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">example_t</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="union">
<h3>Union<a class="headerlink" href="#union" title="Permalink to this headline">¶</a></h3>
<p>Union can carry data of one of multiple other types. It has a control and data fields. Value of the control field determines how the data field should be interpreted. For an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example_t</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">8</span><span class="p">]]</span>  <span class="c1"># u16 | u8</span>
</pre></div>
</div>
<p>is a union where its control bit determines if the data is interpreted as 16-bit or 8-bit unsigned integer. In SystemVerilog this example type would be encoded as:</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">union</span> <span class="k">packed</span>
<span class="p">{</span>
   <span class="kt">logic</span> <span class="p">[</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">type1</span><span class="p">;</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">15</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">type0</span><span class="p">;</span>
<span class="p">}</span> <span class="n">example_data_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="k">packed</span>
<span class="p">{</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span>  <span class="n">ctrl</span><span class="p">;</span>
   <span class="n">example_data_t</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">example_t</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="array">
<h3>Array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h3>
<p>Array is similar to Tuple, but its fields are of the same type. For an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example_t</span> <span class="o">=</span> <span class="n">Array</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>is a structure of 4 fields, each of which is an 8-bit unsigned integers. In SystemVerilog this example type would be encoded as:</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="kt">logic</span> <span class="p">[</span><span class="mi">7</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">example_data_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">example_data_t</span> <span class="p">[</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">3</span><span class="p">]</span> <span class="n">example_t</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="queue">
<h3>Queue<a class="headerlink" href="#queue" title="Permalink to this headline">¶</a></h3>
<p>Queue is a data type which is a bit special in that it describes a transaction and spans multiple cycles. It has a <strong>data</strong> field as well as an <strong>eot</strong> field which marks the end of a transaction. Below, you can see two transactions of a single-level Queue, one consisting of 3 data (cycles 3, 6 and 7), and the other consisting of a single data (cycle 10). Value of 1 for the field <strong>eot</strong> marks the last data within a transaction (cycles 7 and 10).</p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{
  signal: [
  {name: 'clk',           wave: 'p...........'},
  {},
  ['DTI',
  {name: 'data.eot[0]', wave: 'x0..x.01x.1x'},
  {name: 'data.data',   wave: 'x=..x.==x.=x', data: ['1.1', '1.2', '1.3', '2.1']},
  {},
  {name: 'valid',       wave: '01..0.1.0.10'},
  {name: 'ready',       wave: 'x0.1....0.10'}
  ],
],
head:{
  tock:0,
},
}
</script>
</div>
<p>Queue can have multiple levels and hence describe more complex transactions. For an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example_t</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># [u8]^2</span>
</pre></div>
</div>
<p>is a level 2 Queue of 8-bit unsigned integers. Level 2 means that it is a Queue of 8-bit unsigned integer Queues. In SystemVerilog this example type would be encoded as:</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="k">packed</span>
<span class="p">{</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">eot</span><span class="p">;</span>
   <span class="kt">logic</span> <span class="p">[</span><span class="mi">7</span> <span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">example_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Below, you can see a single transactions of a two-level Queue, consisting of two first-level Queues. The higher bit of the <strong>eot</strong> field - <strong>eot[1]</strong>, describes the higher level Queue. It has value of 1 throughout the last first-level Queue (cycles 10 and 11).</p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{
  signal: [
  {name: 'clk',           wave: 'p............'},
  {},
  ['DTI',
  {name: 'data.eot[1]', wave: 'x0..x.0.x.1.x'},
  {name: 'data.eot[0]', wave: 'x0..x.01x.01x'},
  {name: 'data.data',   wave: 'x=..x.==x.==x', data: ['1.1', '1.2', '1.3', '2.1', '2.2']},
  {},
  {name: 'valid',       wave: '01..0.1.0.1.0'},
  {name: 'ready',       wave: 'x0.1....0.1.0'}
  ],
],
head:{
  tock:0,
},
}
</script>
</div>
</section>
</section>
<section id="gear-composition">
<h2>Gear composition<a class="headerlink" href="#gear-composition" title="Permalink to this headline">¶</a></h2>
<p>Any composition of gears again yields a gear which obeys all the listed rules, i.e. gears are closed under composition. This means that composing gears is predictable in many ways and having rich and verified low level library of gears, translates to reliable description of high level modules, where many (especially synchronization) errors are avoided by design. Hence, <strong>Gears</strong> methodology is useful for high level as well as low level modules. <strong>Gears</strong> methodology maximizes module reuse, which in turn minimizes design and debugging efforts.</p>
<div class="figure" id="tikz-2" style="text-align: center"><p><img  src="_images/tikz-b588b70894e8a4dcc98e49e37345812607263fe5.png" alt="Figure made with TikZ" /></p>
<p><span class="caption-text">Example 2-input and 1-output complex gear as a composition of gears G1, G2, G3 and G4</span></p>
</div><p>Each gear is locally synchronized with each of its neighbors, hence no clunky global control FSM is needed to synchronize a high level module. This is a huge benefit for using the <strong>Gears</strong> methodology, because control FSMs are very hard to write and error-prone for complex systems. Furthermore, they make any change to the system very expensive, especially those that alter the data-path latency.</p>
<p>In order to further reduce the cognitive load, testability and amount of errors in a hardware system being developed, <strong>Gears</strong> methodology proposes that gears should aim to be pure (akin to <a class="reference external" href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>). A gear is considered pure if its local state is reset each time after the gear consumes/acknowledges its input data. If a gear operates on Queues, it is still considered pure if its local state is reset after the whole Queue has been processed.</p>
</section>
<section id="functors">
<span id="gears-functors"></span><h2>Functors<a class="headerlink" href="#functors" title="Permalink to this headline">¶</a></h2>
<p>Functors are powerful patterns for gear composition that significantly improve possibilities for gear reuse. There is one functor for each complex data type. Functors allow for gears that operate on simpler data types to be used in context where a more complex data type is needed.</p>
<section id="tuple-functor">
<h3>Tuple functor<a class="headerlink" href="#tuple-functor" title="Permalink to this headline">¶</a></h3>
<p>Tuple functors are useful in context where we need to operate on Tuples of some data types, and we already have gears that implement desired transformation but operate on data types that are individual fields of the Tuple. Consider a simple example where a complex number is implemented as the following Tuple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cmplx_t</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">]]</span>  <span class="c1"># (u16, u16)</span>
</pre></div>
</div>
<p>Suppose we would like to implement a module that doubles the complex numbers, and we already have a module that doubles 16-bit unsigned numbers that we would like to reuse. We could than make use of the Tuple functor structure to achieve this.</p>
<img alt="_images/tuple_functor.png" class="align-center" src="_images/tuple_functor.png" />
<p>Within Tuple functor, input Tuple data is first split into two, fed to individual functions and then recombined into a Tuple. <strong>PyGears</strong> can automatically generate such a structure based on the input type and gears that are to be used inside a functor.</p>
</section>
<section id="union-functor">
<h3>Union functor<a class="headerlink" href="#union-functor" title="Permalink to this headline">¶</a></h3>
<p>Union functors are useful in context where we need to operate on Unions of some data types, and we already have gears that implement desired transformation but operate on data types that are part of the Union. Consider a simple example where a number can be represented by either an Uint[16] or a Q8.8 fixed point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_t</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">8</span><span class="p">]]]</span>  <span class="c1"># u16 | (u8, u8)</span>
</pre></div>
</div>
<p>Suppose we would like to implement a module that decrements the number, and we already have a module that decrements 16-bit unsigned integers and a module that decrements Q8.8 fixed point numbers that we would like to reuse. We could than make use of the Union functor structure to achieve this.</p>
<img alt="_images/union_functor.png" class="align-center" src="_images/union_functor.png" />
<p>Within Union functor, input Union data is routed to one of two gears by the <strong>Demux</strong> gear, depending on which data type the Union data carries, i.e by the  value of the <strong>ctrl</strong> field. After processing by the gears, output data is wrapped in Union data type again by the <strong>Mux</strong> gear. <strong>PyGears</strong> can automatically generate such a structure based on the input type and gears that are to be used inside a functor.</p>
</section>
<section id="array-functor">
<h3>Array functor<a class="headerlink" href="#array-functor" title="Permalink to this headline">¶</a></h3>
<p>Array functor operates in the same manner as Tuple functor.</p>
</section>
<section id="queue-functor">
<h3>Queue functor<a class="headerlink" href="#queue-functor" title="Permalink to this headline">¶</a></h3>
<p>Queue functors are useful in context where we need to operate on Queues of some data types, and we already have gears that implement desired transformation but operate on single data or lower level Queues. They are akin to the Python’s map function operating on a list. Consider a simple example where there is a Queue of numbers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_num_t</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">[</span><span class="n">Uint</span><span class="p">[</span><span class="mi">16</span><span class="p">]]</span>  <span class="c1"># [u16]</span>
</pre></div>
</div>
<p>Suppose we would like to implement a module that multiplies each number in the Queue by 2, and we already have a module that multiplies single numbers that we would like to reuse. We could than make use of the Queue functor structure to achieve this.</p>
<img alt="_images/queue_functor.png" class="align-center" src="_images/queue_functor.png" />
<p>Within Queue functor, input Queue data is first split into the individual data and the Queue structure, also called the envelope. Queue structure is defined by the pattern of its <strong>eot</strong> field. The individual data is fed to the function and is then recombined with the envelope to produce the output Queue. <strong>PyGears</strong> can automatically generate such a structure based on the input type and gears that are to be used inside a functor.</p>
</section>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">HW Design: A Functional Approach</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=bogdanvuk&repo=pygears&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<hr />
<hr />
<h3><a href="https://docs.pygears.org/blog/blog/category/release.html">Release notes</a></h3>
<hr />
<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="presentation_pygears.html">Presentation for beginners</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Quick introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction to Gears</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#one-interface">One interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#powerful-type-system">Powerful type system</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gear-composition">Gear composition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functors">Functors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="typing.html">Typing</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="third_party_tools.html">Third party Tools</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Bogdan Vukobratovic.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/gears.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>